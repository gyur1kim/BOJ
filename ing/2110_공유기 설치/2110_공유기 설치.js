let [NC, ...coords] = `5 3
1
2
8
4
9`.split('\n');

let [N, C] = NC.split(' ').map(Number);    // 집 개수, 공유기 개수
coords = coords.map(Number).sort((a, b) => a - b)  // 좌표 숫자로 변환 후 정렬

/*
 * 우선 최대 너비를 구해보고, binary search를 하면 될 것 같다..
 * 1. 가장 앞 집과 가장 뒷 집 사이의 거리를 공유기 개수로 나눠본다.
 * 2. 그 값을 공유기 거리라고 생각하고, 앞에서부터 공유기를 설치해본다..
 * 2-1. 공유기를 설치할건데, 다음 집이 기존 거리를 초과하면 그 이전 집에 설치한다.
 * 3-1. 공유기를 설치했는데 공유기 개수가 C보다 적다 => 현재 거리가 너무 넓어서 공유기가 적어도 됐던 것 => 거리를 좁힌다.
 * 3-2. 공유기를 설치했는데 공유기 개수가 C보다 크다 => 현재 거리가 너무 좁다!! => 거리를 늘린다.
 */

let start, end, mid;
start = coords[0];
end = coords[N-1];
mid = Math.ceil((end - start) / C);



